"""Prime-generating polynomial utilities.

Provides tools for analyzing quadratic polynomials of the form an^2 + bn + c
that generate high densities of prime numbers, as seen in Ulam spiral diagonals.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Iterator

import numpy as np

from prime_plot.core.sieve import is_prime, generate_primes


@dataclass
class PrimePolynomial:
    """Represents a quadratic polynomial f(n) = an^2 + bn + c.

    Attributes:
        a: Coefficient of n^2.
        b: Coefficient of n.
        c: Constant term.
        name: Optional name for famous polynomials.
    """

    a: int
    b: int
    c: int
    name: str | None = None

    def evaluate(self, n: int | np.ndarray) -> int | np.ndarray:
        """Evaluate the polynomial at n."""
        return self.a * n * n + self.b * n + self.c

    def evaluate_range(self, start: int, stop: int) -> np.ndarray:
        """Evaluate polynomial for n in [start, stop)."""
        n = np.arange(start, stop)
        return self.evaluate(n)

    def prime_count(self, start: int, stop: int) -> int:
        """Count how many values in [start, stop) are prime."""
        values = self.evaluate_range(start, stop)
        return sum(1 for v in values if v > 1 and is_prime(int(v)))

    def prime_density(self, start: int, stop: int) -> float:
        """Calculate the fraction of prime values in [start, stop)."""
        count = stop - start
        if count <= 0:
            return 0.0
        return self.prime_count(start, stop) / count

    def prime_sequence(self, start: int = 0) -> Iterator[tuple[int, int]]:
        """Yield (n, f(n)) pairs where f(n) is prime.

        Args:
            start: Starting value of n.

        Yields:
            Tuples of (n, prime_value).
        """
        n = start
        while True:
            value = self.evaluate(n)
            if value > 1 and is_prime(int(value)):
                yield n, int(value)
            n += 1

    def consecutive_prime_run(self, start: int = 0) -> int:
        """Count consecutive primes starting from start.

        Returns:
            Number of consecutive prime values starting at f(start).
        """
        count = 0
        n = start
        while True:
            value = self.evaluate(n)
            if value < 2 or not is_prime(int(value)):
                break
            count += 1
            n += 1
        return count

    def hardy_littlewood_constant(self) -> float:
        """Estimate the Hardy-Littlewood constant A for this polynomial.

        The constant A appears in Conjecture F and predicts the asymptotic
        density of primes generated by the polynomial. Higher A means more primes.

        Returns:
            Estimated constant (requires discriminant calculation).
        """
        discriminant = self.b * self.b - 4 * self.a * self.c

        if discriminant == 0:
            return 0.0

        primes = generate_primes(1000)
        product = 1.0

        for p in primes[1:]:
            p = int(p)
            legendre = self._legendre_symbol(discriminant, p)

            if p == 2:
                if discriminant % 8 == 1:
                    factor = 2.0
                elif discriminant % 8 == 5:
                    factor = 2.0
                elif discriminant % 4 == 0:
                    factor = 1.0
                else:
                    factor = 0.0
            else:
                if legendre == 0:
                    factor = 1.0 / (1.0 - 1.0 / p)
                else:
                    factor = (1.0 - legendre / p) / (1.0 - 1.0 / p)

            product *= factor

            if abs(factor - 1.0) < 1e-10:
                continue

        return product

    @staticmethod
    def _legendre_symbol(a: int, p: int) -> int:
        """Compute the Legendre symbol (a/p)."""
        if p == 2:
            return 0

        a = a % p
        if a == 0:
            return 0

        result = pow(a, (p - 1) // 2, p)
        if result == p - 1:
            return -1
        return result

    def __str__(self) -> str:
        parts = []

        if self.a != 0:
            if self.a == 1:
                parts.append("n^2")
            elif self.a == -1:
                parts.append("-n^2")
            else:
                parts.append(f"{self.a}n^2")

        if self.b != 0:
            if self.b == 1:
                parts.append("n" if not parts else "+ n")
            elif self.b == -1:
                parts.append("-n" if not parts else "- n")
            elif self.b > 0:
                parts.append(f"{self.b}n" if not parts else f"+ {self.b}n")
            else:
                parts.append(f"- {-self.b}n")

        if self.c != 0:
            if self.c > 0:
                parts.append(f"{self.c}" if not parts else f"+ {self.c}")
            else:
                parts.append(f"- {-self.c}")

        formula = " ".join(parts) if parts else "0"

        if self.name:
            return f"{self.name}: f(n) = {formula}"
        return f"f(n) = {formula}"


FAMOUS_POLYNOMIALS = {
    "euler": PrimePolynomial(1, -1, 41, "Euler (1772)"),
    "euler_variant": PrimePolynomial(1, 1, 41, "Euler Variant"),
    "high_density": PrimePolynomial(4, -2, 41, "High Density"),
    "legendre": PrimePolynomial(1, 1, 17, "Legendre"),
    "ulam_diagonal": PrimePolynomial(4, 2, 41, "Ulam Diagonal"),
}


def find_dense_polynomials(
    a_range: tuple[int, int],
    b_range: tuple[int, int],
    c_range: tuple[int, int],
    eval_range: tuple[int, int] = (0, 100),
    min_density: float = 0.3,
) -> list[tuple[PrimePolynomial, float]]:
    """Search for polynomials with high prime density.

    Args:
        a_range: Range for coefficient a (start, stop).
        b_range: Range for coefficient b (start, stop).
        c_range: Range for coefficient c (start, stop).
        eval_range: Range of n values to evaluate.
        min_density: Minimum prime density to include.

    Returns:
        List of (polynomial, density) tuples sorted by density descending.
    """
    results = []

    for a in range(a_range[0], a_range[1]):
        if a == 0:
            continue

        for b in range(b_range[0], b_range[1]):
            for c in range(c_range[0], c_range[1]):
                poly = PrimePolynomial(a, b, c)
                density = poly.prime_density(eval_range[0], eval_range[1])

                if density >= min_density:
                    results.append((poly, density))

    results.sort(key=lambda x: x[1], reverse=True)
    return results


def ulam_diagonal_polynomial(diagonal_id: int) -> PrimePolynomial:
    """Get the polynomial corresponding to an Ulam spiral diagonal.

    In the Ulam spiral, diagonals correspond to polynomials of the form
    4n^2 + bn + c where b is determined by the diagonal direction.

    Args:
        diagonal_id: Identifier for the diagonal (0-7 for 8 main diagonals).

    Returns:
        Polynomial for the specified diagonal.
    """
    b_values = [2, 4, 0, -2, 2, 4, 0, -2]
    c_base = [1, 1, 1, 1, 0, 0, 0, 0]

    b = b_values[diagonal_id % 8]
    c = c_base[diagonal_id % 8]

    return PrimePolynomial(4, b, c, f"Ulam Diagonal {diagonal_id}")
